/*
*  Generated by AN Unibo
*/
package it.unibo.contact.platformuv;
import it.unibo.is.interfaces.IMessage;
import it.unibo.is.interfaces.IOutputView;
import it.unibo.is.interfaces.platforms.IAcquireManyReply;
import it.unibo.is.interfaces.platforms.IMessageAndContext;
import java.util.Vector;

public class AcquireManyReply extends Thread implements IAcquireManyReply{
private Vector<IMessage> queries;
private IOutputView view;
private int numOfResponse; 
//private Vector<IMessage> lastAnswers;
private int numOfAnswerAcquired = 0;
private String subjName;
private java.util.Hashtable<String,Integer> lastMsgRdMemo = 
			new java.util.Hashtable<String,Integer>();	
private java.util.Hashtable<Integer,Vector<IMessage>> answerAcquired = 
	new java.util.Hashtable<Integer,  Vector<IMessage> >();	
private java.util.Hashtable<Integer,Integer> numOfAnswersForReply = 
	new java.util.Hashtable<Integer, Integer>();	
	
	 	public AcquireManyReply( String subjName,Vector<IMessage> queries, IOutputView view  ){
	 		this.subjName = subjName;
	 		this.queries = queries;
	 		this.view = view;
		 	numOfResponse = queries.size();
//			lastAnswers = new Vector<IMessage>();
			start();
	 	}
	 	
	 	
	 	public void run(){
	 		while( numOfAnswerAcquired < numOfResponse   )
				try {
					Vector<IMessage> answers = new Vector<IMessage>();
					answerAcquired.put(numOfAnswerAcquired, answers);
					waitForNextInput(queries);					
				} catch (Exception e) {
 					//e.printStackTrace();
 					System.out.println("connect ERROR " + e.getMessage() );
				}
	 	}

	 	protected void  waitForNextInput( Vector<IMessage> queries ) throws Exception {
 	 	Vector<IMessage> tempQueries = new Vector<IMessage>();
 	 	int na = 0;
			if( queries.size() > 0 ){	
				IMessage mr = LindaLike.getSpace().select(subjName,lastMsgRdMemo, queries);
				tempQueries.add( getQuerySelected(mr,queries) ) ;
				//System.out.println("AcquireManyReply tempQueries "  + mr  );
				//acquire all the answers, including endOfAnswerSysMsg				 
				do{ 
					mr=LindaLike.getSpace().in( ""+mr);
					System.out.println("AcquireManyReply acquired "  + mr  );
					na = addReply( mr );
					if( mr.msgContent().contains(IMessageAndContext.endMessage)) break; //ignore sys messages
					mr = LindaLike.getSpace().select(subjName,lastMsgRdMemo, tempQueries);
				}while(true);
				updateAnswers(na);
 			}
	 	}
	 	
	 	protected synchronized void updateAnswers(int na){
			//update the numOfAnswersForReply for the reply numOfAnswerAcquired
			numOfAnswersForReply.put(numOfAnswerAcquired, na);
			//wake up some waiting subject
			numOfAnswerAcquired++;
			System.out.println("numOfAnswerAcquired ... "+ numOfAnswerAcquired);
			notifyAll();	 		
	 	}
	 	

	 	protected IMessage getQuerySelected(  IMessage mr, Vector<IMessage> queries ){
	 		java.util.Iterator<IMessage> itmq = queries.iterator();
	 		while( itmq.hasNext() ){
	 			IMessage m = itmq.next();
	 			if( m.msgEmitter().equals(mr.msgEmitter()))
	 				return m;
	 		}
	 		return null; //should never be here
	 	}
	 	
		protected  int  addReply( IMessage response ){
//			add the answer to the vector for numOfAnswerAcquired
			Vector<IMessage> answers =  answerAcquired.get(numOfAnswerAcquired);
			answers.add(response);
			return answers.size();
		}

		public int numOfReplyExpected(){
			return numOfResponse;
		}

		public int numOfReplyReceived(){
			return numOfAnswerAcquired;
		}

		
		public synchronized IMessage acquireReply(int n) throws Exception{
			//System.out.println("acquireReply ... "+ n  );
			if( n > numOfAnswerAcquired ) wait();
			Vector<IMessage> answers =  answerAcquired.get(n-1);
			if( answers.size() > 0 ) {
				IMessage m = answers.remove(0);
				//System.out.println("acquireReply ... "+ n + " -> " + m);
				return m;
			}
			String exMsg = MsgUtil.buildExceptionTerm(
					""+queries.elementAt(n-1),"exception(no more element)" );			
			//System.out.println("acquireReply ...exMsg "+ exMsg);
			return new Message(exMsg);
				//lastAnswers.get(n-1);

/*
 * 
---------------------------------------------
Version to ignore the IMessageAndContext.endMessage 
in the case of no step answer
---------------------------------------------

			System.out.println("acquireReply ... "+ n  );
			if( n > numOfAnswerAcquired ) wait();
			Vector<IMessage> answers =  answerAcquired.get(n-1);
			if( numOfAnswersForReply.get(n-1) == 2 ){
				//consume IMessageAndContext.endMessage in automatic way and return the first answer
				IMessage m = answers.remove(0);
				System.out.println("acquireReply ... "+ n + " -> " + m);
				answers.remove(0); //remove endOf
				return m;				
			}
			else if( answers.size() > 0 ) {
			//case of answer sent by step	
			//the IMessageAndContext.endMessage must be handled at application level
				IMessage m = answers.remove(0);
				System.out.println("acquireReply ... "+ n + " -> " + m);
				return m;
			}
			String exMsg = MsgUtil.buildExceptionTerm(
					""+queries.elementAt(n-1),"exception(no more element)" );			
			return new Message(exMsg);
 */
		}
		
		public synchronized IMessage acquireReply(int n, int timeOut) throws Exception{
			//Wait until timeout or reply
			new Timer( n,""+queries.elementAt(n-1),answerAcquired.get(n-1),timeOut );	
			if( n > numOfAnswerAcquired ) wait();
			
			Vector<IMessage> answers =  answerAcquired.get(n-1);
			if( answers.size() > 0 ) {
				IMessage m = answers.remove(0);
				return m;
			}
			String exMsg = MsgUtil.buildExceptionTerm(
						""+queries.elementAt(n-1),"exception(no more element)" );			
			return new Message(exMsg);
		}		
 
//		protected synchronized void  terminate(   ){
//			try {
////				lastAnswers.add( new Message("exception") ) ;
////				int nl = lastAnswers.size();
//				Vector<IMessage> answers =  answerAcquired.get(numOfAnswerAcquired);
//				answers.add(new Message("exception"));
//				notifyAll();
//			} catch (Exception e) {
//				e.printStackTrace();
//			}
//		}
}
