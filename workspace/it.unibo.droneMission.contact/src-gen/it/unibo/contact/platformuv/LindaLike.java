/*
*  Generated by AN Unibo
*/
package it.unibo.contact.platformuv;
import java.util.*;
import alice.tuprolog.*;
import alice.tuprolog.Number;
import java.util.Observable;
import java.util.Observer;
import it.unibo.is.interfaces.IMessage;
import it.unibo.is.interfaces.IOutputView;
import it.unibo.is.interfaces.platforms.ILindaLike;
 
 

//The space is implemented as an observable
public class LindaLike extends Observable implements ILindaLike{
	
//Local state
protected static ILindaLike space = null;
private static int msgCounter = 1;
private static Prolog engine 	= null;
private boolean debug 	= false;
protected IOutputView view = null;

public LindaLike(IOutputView aview){
	if( view == null ) view = aview;
	engine 	= new Prolog();
	String debugOn = System.getProperty("coreTrace");
	if( debugOn != null ) {
		debug = System.getProperty("coreTrace").equals("set") ;
	}
//	debug=true;
}

public static synchronized ILindaLike initSpace(IOutputView aview){
// if( space == null ){
	LindaLike myspace = new LindaLike(aview);
	space = myspace;
	myspace.doprintln(" ******************************************** ");
	myspace.doprintln(" LindaLike: init and cleans a singleton space ");
	myspace.doprintln(" ******************************************** ");
	myspace.clean();
// }
 return space;
}

public static synchronized ILindaLike getSpace(){
	if( space == null ){
		LindaLike myspace = new LindaLike(null);
		myspace.doprintln(" ******************************************** ");
		myspace.doprintln(" LindaLike creates a singleton space no view");
		myspace.doprintln(" ******************************************** ");
		space = myspace;
	}
	return space;
}

public static synchronized ILindaLike getSpace(IOutputView view){
	if( space == null ){
		LindaLike myspace = new LindaLike(view);
		space = myspace;
		myspace.doprintln(" **************************************** ");
		myspace.doprintln(" LindaLike creates a singleton space");
		myspace.doprintln(" **************************************** ");
	}
	return space;
}

public static synchronized Prolog getEngine( ){
	return engine;
}

public synchronized void clean(){
 if( space != null && engine != null ){
	engine.clearTheory();
	((LindaLike)space).deleteObservers();
	msgCounter = 1;
 }
}

public static synchronized ILindaLike getSpace(java.util.Observer observ){
	if( space == null ){
		System.out.println(" **************************************************** ");
		System.out.println(" LindaLike creates a singleton space with an observer");
		System.out.println(" **************************************************** ");
		LindaLike myspace = new LindaLike(null);
		register( observ ); 
		space = myspace;
	}
	return space;
}

public static void register( Observer obj ){
	if( space != null ) ((LindaLike)space).addObserver( obj );
}
public static void unregister( Observer obj ){
	if( space != null ) ((LindaLike)space).deleteObserver( obj );
}

protected void raiseObservableEvent(String msg){
  	setChanged();
  	try{
  		notifyObservers( msg );
  	}catch(Exception e){
  		println("raiseObservableEvent error "  + e);
  	}
}
 
// ---------------------------------------------
// in
// ---------------------------------------------
  public synchronized IMessage in( String queryS ) throws Exception {
  Term term = null;
  IMessage answer = null;	
	while(true){
	try {
//Messages with timestamp  
		String myQuery = "mmm(" + queryS +"," + "MsgNum)" ;
//--- remove token myQuery		
		term = queryT( "retract("+myQuery+")" ); 			//term has the form retract( X )
//--- end remove token myQuery		 
		Term content 		 = ((Struct)term).getArg(0);	//content has the form mmm( X, N )
		//println("in/1 " + queryS + " gets: " + content);		
		Term userContent 	= ((Struct)content).getArg(0);	
		Term userMsgNum		= ((Struct)content).getArg(1);
 		println("in/1 " + queryS + " gets: " + userContent  + " " + userMsgNum);
 		raiseObservableEvent( "IN"+term.toString() );
// 		Term varN = ((Var)userMsgNum).getTerm() ;
//		int n = ((Number)varN).intValue();
		Term varN;
		if( userMsgNum instanceof Var ) 
			varN       = ((Var)userMsgNum).getTerm() ;
		else varN = userMsgNum;
//    	println("in varN=" + varN);
		int N = -1;
		if( varN instanceof Number )
			N = ((Number)varN).intValue();
		else N = 0;
// 		println("in  N = " +   N);
		answer = new Message( N, userContent );
//		if( answer.msgContent().contains("exception")) throw new Exception(answer.msgContent());
//		println("in/1 " + queryS + " returns: " + answer);
		return answer;  
	} catch (Exception e) { //retract (remove) fails
//		println("in/1 ERROR " + e.getMessage());
		println("in WAITS *** " +  queryS);
		wait(); 
		println("in RESUMES *** " +  queryS );
	}
	}//while 				
  }  

// ---------------------------------------------
// rd
// ---------------------------------------------
  public synchronized IMessage rd( int LastMsgNum, String queryMsg ) throws Exception {
//	println(" *** rd " + LastMsgNum + " " + queryMsg);
	String query = "mmm(" + queryMsg +"," + "MsgNum),MsgNum>"+ LastMsgNum ;
//--- check token query
	IMessage answerRd = null;	
 	println(" *** rd " + query +"." );
	SolveInfo sol = engine.solve(query+".");
   	if( sol.isSuccess() ){
//--- end check token query  	
    	println("rd " + query + " => " + sol.getSolution());
    	raiseObservableEvent( "RD"+sol.getSolution() );
   		Term term = sol.getSolution();
		Term content 	= ((Struct)term).getArg(0);	//term = A , X>Y , quindi prendo A
		Term msgNum 	= ((Struct)content).getArg(1); //content=mmm( A, N) quindi prendo N
		Term varN;
		if( msgNum instanceof Var ) 
			varN       = ((Var)msgNum).getTerm() ;
		else varN = msgNum;
 //   	println("rd varN=" + varN);
		int N = -1;
		if( varN instanceof Number )
			N = ((Number)varN).intValue();
		else N = 0;
// 		println("rd  N = " +   N);
		Term msg		= ((Struct)content).getArg(0); //content=mmm( A, N) quindi prendo A
//    	println(" *** rd " + N + " " + msg);
		answerRd = new Message( N , msg );
  		return answerRd   ;
   	}
   	else  	return null;
  }  
//---------------------------------------------
//rdMostRecent
//---------------------------------------------
 public  IMessage rdMostRecent( int LastMsgNum, String queryMsg ) throws Exception {
	 IMessage m = rd(LastMsgNum,  queryMsg ) ;
	 IMessage mOk = null;
	 while(m != null ){
		 mOk = m;
		 LastMsgNum = m.getMsgSeqNum();
		 m = rd(LastMsgNum,  queryMsg );
	 }
	 return mOk;
 }

// ---------------------------------------------
// rdw (resuming)
// ---------------------------------------------
  public synchronized IMessage rdw( int LastMsgNum, String queryMsg ) throws Exception {
 	println("rdw  " + LastMsgNum + " " + queryMsg);
	String query = "mmm(" + queryMsg +"," + "MsgNum),MsgNum>"+ LastMsgNum ;
	IMessage answer = null;	
	while(true){
//--- check token query	
	SolveInfo sol = engine.solve(query+".");
   	if( sol.isSuccess() ){
//--- end check token query   	
   		println("rdw " + query + " => " + sol.getSolution());
    	raiseObservableEvent( "RW"+sol.getSolution() );
   		Term term = sol.getSolution();
		Term content 	= ((Struct)term).getArg(0);	//term = A , X>Y , quindi prendo A
		Term msgNum 	= ((Struct)content).getArg(1); //content=mmm( A, N) quindi prendo N
		Term varN;
		if( msgNum instanceof Var ) 
			varN       = ((Var)msgNum).getTerm() ;
		else varN = msgNum;
//    	println("rdw varN=" + varN);
		int N = -1;
		if( varN instanceof Number )
			N = ((Number)varN).intValue();
		else N = 0;
// 		println("rdw  N = " +   N);
		Term msg		= ((Struct)content).getArg(0); //content=mm( A, N) quindi prendo A
		answer = new Message( N , msg );
 		return answer   ;
   	}
   	else {
 		println("rdw WAITS *** " + Thread.currentThread()+ " "  );
		wait(); 
		println("rdw RESUMES *** " + Thread.currentThread()+ " "  );
   	}
   	}
  }
//---------------------------------------------
//rdwMostRecent
//---------------------------------------------
 public  IMessage rdwMostRecent( int LastMsgNum, String queryMsg ) throws Exception {
	 IMessage m = rdw(LastMsgNum,  queryMsg ) ;
	 IMessage mOk = null;
	 while(m != null ){
		 mOk = m;
		 LastMsgNum = m.getMsgSeqNum();
		 m = rd(LastMsgNum,  queryMsg );
	 }
	 return mOk;
 }
  
// -----------------------------------------------------------------
// out
// -----------------------------------------------------------------
  public synchronized void out( String msg ) throws Exception {
//Messages with timestamp   
  		String outMsg= "mmm(" + msg + " , "+ msgCounter++ + ")";
//--- insert token outMsg   		
     	println(" out " + outMsg   );
		queryT( "assertz("+ outMsg +")" );
//--- end insert token query  		
		raiseObservableEvent( outMsg ) ;
		//System.out.println("out/1 " + msg);
		notifyAll();
  }

 
// ---------------------------------------------
// inMany  
// ---------------------------------------------
  public synchronized Vector<IMessage> inMany( 
		  	Vector<String> tokens)throws Exception {
  Iterator<String> iter;
  int nD = tokens.size();
	  Vector<IMessage> answer = new Vector<IMessage>(nD);
	  boolean checked = false;
	  boolean failure = false;
	  	while( ! checked ){
	  		failure = false;
	  		iter = tokens.iterator();
  	  		while( iter.hasNext() ){
	  	 	String query = (String)iter.next();
	  		IMessage mr = rd( 0, query );
	  			if( mr == null ){
	  				failure = true;
	  				break;
	  			}
	  		}//while iter
	  		if( failure ){
	  		println("inMany waits " +  tokens);
	  			wait();
	  		println("inMany resumes " + tokens );
	  		}else checked = true;
	  		
	  	}//while checked
 	  	//Now all the tokens are available
	  	iter = tokens.iterator();
	  	while( iter.hasNext() ){
	  		IMessage mt = in( (String)iter.next() );//no suspension possible
	  		answer.add(mt);
	  	}
 	  return answer;
  }

 

// ---------------------------------------------
// select  
// ---------------------------------------------
public synchronized IMessage select( String subjName,
		Hashtable<String,Integer> lastMsgRdMemo, List<IMessage> queries ) throws Exception {
IMessage answerRd = null;	
	println("select " + queries   );
//	if( queries.size() == 0 ) wait(); //perhaps some remote signal will appear
	while(true){
	Iterator<IMessage> iter = queries.iterator();
	while( iter.hasNext() ){
		IMessage queryMsg = iter.next();
		//Check if there is some message that solves the current queryS
		String query;
		if( queryMsg.getMsgName().contains("_")){ //is not a signal
			 query = "mmm(" + queryMsg +"," + "MsgNum)"  ;
		}else{
			 query = "mmm(" + queryMsg +"," + "MsgNum),MsgNum>"+ lastMsgRdMemo.get(queryMsg.getMsgName()+subjName) ;
		}
		println("select query=" + query );
		SolveInfo sol = engine.solve(query+".");
	   	if( sol.isSuccess() ){
	   	   		Term term = sol.getSolution();
	   	   		println("select " + queryMsg + " => " + term );
	   			Term content;
	 	   		queries.remove(queryMsg);
		   		queries.add(queryMsg); //re-insert at the end, to avoid starvation
	   			if( ! queryMsg.getMsgName().contains("_")){ //IS a signal
		   			 content 	= ((Struct)term).getArg(0);	//term = A , X>Y , quindi prendo A
	   			}else{ //IS NOT a signal
		   			content 	= term;	 
 	   	   		}
	   			Term msgNum 	= ((Struct)content).getArg(1); //content=mmm( A, N) quindi prendo N
	   			if( msgNum instanceof Var ) msgNum = msgNum.getTerm();
	   			int	 N			= new Integer( ""+msgNum ).intValue();
	   			lastMsgRdMemo.put(queryMsg.getMsgName(), N);
	   			Term msg		= ((Struct)content).getArg(0); //content=mmm( A, N) quindi prendo A
	   			if( msg instanceof Var ) msg = msg.getTerm();
	   			answerRd 		= new Message( N , msg );
	   	   		raiseObservableEvent( "OM"+answerRd ) ;
	   	  		return answerRd   ;	   	   			
	   }	
	   	println( query + " fails" );
	}
	//System.out.println("select WAITS *** " + Thread.currentThread() );
	//Before waiting,  the SenseRemote threads for all the events should be active
	wait(); 
	//System.out.println("select RESUMES *** " + Thread.currentThread()  );
	}//while
}

public synchronized IMessage selectMostRecent( String subjName,
		Hashtable<String,Integer> lastMsgRdMemo, List<IMessage> queries ) throws Exception {
	IMessage answerRd = null;
	IMessage answerOk = null;
	println("select " + queries   );
//	if( queries.size() == 0 ) wait(); //perhaps some remote signal will appear
	while(true){
	Iterator<IMessage> iter = queries.iterator();
	while( iter.hasNext() ){
		IMessage queryMsg = iter.next();
		//Check if there is some message that solves the current queryS
		String query;
		if( queryMsg.getMsgName().contains("_")){ //is not a signal
			 query = "mmm(" + queryMsg +"," + "MsgNum)"  ;
		}else{
			 query = "mmm(" + queryMsg +"," + "MsgNum),MsgNum>"+ lastMsgRdMemo.get(queryMsg.getMsgName()+subjName) ;
		}
		println("select query=" + query );
		SolveInfo sol = engine.solve(query+".");	
		SolveInfo solOk = null;
	   	while( sol.isSuccess()  ){
	   		solOk = sol;
	   	   	//System.out.println("solOk " + solOk + " => " + sol.hasOpenAlternatives() );
	   		if(sol.hasOpenAlternatives() )
	   			sol = engine.solveNext();	//backtracking
	   		else break;
	   	}//while
	   	if( solOk != null ){
	   			sol = solOk;
 	   	   		Term term = sol.getSolution();
	   	   		println("select " + queryMsg + " => " + term );
	   			Term content;
	 	   		queries.remove(queryMsg);
		   		queries.add(queryMsg); //re-insert at the end, to avoid starvation
	   			if( ! queryMsg.getMsgName().contains("_")){ //IS a signal
		   			 content 	= ((Struct)term).getArg(0);	//term = A , X>Y , quindi prendo A
	   			}else{ //IS NOT a signal
		   			content 	= term;	 
 	   	   		}
	   			Term msgNum 	= ((Struct)content).getArg(1); //content=mmm( A, N) quindi prendo N
	   			if( msgNum instanceof Var ) msgNum = msgNum.getTerm();
	   			int	 N			= new Integer( ""+msgNum ).intValue();
	   			lastMsgRdMemo.put(queryMsg.getMsgName(), N);
	   			Term msg		= ((Struct)content).getArg(0); //content=mmm( A, N) quindi prendo A
	   			if( msg instanceof Var ) msg = msg.getTerm();
	   			answerRd 		= new Message( N , msg );
	   	   		raiseObservableEvent( "OM"+answerRd ) ;
	   	   		return answerRd   ;
	   	}//if	
	}//while iter
	//System.out.println("select WAITS *** " + Thread.currentThread() );
	//Before waiting,  the SenseRemote threads for all the events should be active
	wait(); 
	//System.out.println("select RESUMES *** " + Thread.currentThread()  );
	}//while
	
}

public void terminate() throws Exception{
	
}

/* --------------------------
	WORKING UTILITIES
 ---------------------------- */
	protected synchronized Term queryT( String queryS ) throws Exception  {
		SolveInfo info;
			info = engine.solve( queryS+".");
			Term  solution = info.getSolution();
			//println(" query  solution " + solution );
 			return solution;
	}//query
	
	

/* --------------------------
	OTHER UTILITIES
 ---------------------------- */
 	protected String buildMsgStr( /* EXPAND MsgParams FOR msgStruct-È */ ){
 		return ""; //channel + "(" + senderName +","+msgId+","+msg+","+ msgNum +")";
 	}
 
 	protected String toStr( int n){
 		return new Integer(n).toString();
 	}
 
	public void doprintln( String msg){
		if( view != null )
			view.addOutput( msg );
		else System.out.println(msg);		
	}

	protected void println( String msg){
		String m = "    --- LindaLike "+msg;
		if( debug ) 
 			doprintln(m);
	}
}
