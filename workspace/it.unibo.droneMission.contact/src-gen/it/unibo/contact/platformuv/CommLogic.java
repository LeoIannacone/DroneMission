/*
*  Generated by AN Unibo
*/
package it.unibo.contact.platformuv;
import it.unibo.is.interfaces.IMessage;
import it.unibo.is.interfaces.IOutputView;
import it.unibo.is.interfaces.platforms.IAcquireOneReply;
import it.unibo.is.interfaces.platforms.IAcquireManyReply;
import it.unibo.is.interfaces.platforms.ILindaLike;
import it.unibo.is.interfaces.platforms.IMessageAndContext;
import java.util.Vector;
import java.util.Iterator;
import it.unibo.is.interfaces.ISysKb;
import java.util.Hashtable;
import it.unibo.is.interfaces.IPolicy;

public class CommLogic{
protected ILindaLike space = LindaLike.getSpace();
protected IOutputView view;
 
	public CommLogic(IOutputView view) {
		this.view = view;
	}
public  IAcquireOneReply outIn( 
		String receiver,String msgId,String sender,String msg,String queryAnswer ) throws Exception {
	IMessage m = new Message(msg);
	outOnly( receiver, msgId ,sender,m  );
//	outOnly( receiver, msgId ,sender,msg );
	return new AcquireOneReply(space,queryAnswer,view);
}


public  void outOnly( String receiver,String msgId,String sender,IMessage msg ) throws Exception {
	ILindaLike support = PlatformExpert.findOutSupport(receiver, msgId ,sender,view);
	if( ! (support instanceof LindaLike) ){
	//Store a outgoing message in the space, to allow observation (with destruction)
	IMessage m = new Message("outgoing(" + msg +")");
	space.out(""+m);
	}
 	//Send on the network if the outgoing message is still in
	//if( space.rd( 0, ""+m) != null )
 		support.out(""+msg);
}


//Case for no destination (signals)
public  void outOnly( String sender, String msgId, IMessage msg ) throws Exception {
	ILindaLike support =  PlatformExpert.findOutSupport("", msgId ,sender,view);
	if( ! (support instanceof LindaLike) ){
	//Store a outgoing message in the space, to allow observation
	IMessage m = new Message("outgoing(" + msg +")");
	space.out(""+m);
	}
		//Send  
	support.out(""+msg);
}

//Operation with answer 
public  IMessageAndContext inOut( String receiver,String msgId, String queryS ) throws Exception {
	ILindaLike support =  PlatformExpert.findInSupport(receiver, msgId ,  true, view);
		IMessage inMsg =  space.in( queryS );
	return new MessageAndContext(support,inMsg,receiver); //support is needed to send the answer
}

public  IMessage  inOutAck( String receiver,String msgId, String queryS ) throws Exception {
	ILindaLike support =  PlatformExpert.findInSupport(receiver, msgId ,  true,view);
		IMessage inMsg =  space.in( queryS );	
	String channelId = MsgUtil.channel3( inMsg.msgEmitter(), receiver, msgId);
	//String outMsg = MsgUtil.bm(channelId, receiver, msgId , "backInfo", inMsg.msgNum());
	//support.out( outMsg ); //support is needed to send the answer
	String outMsg = MsgUtil.bm(channelId, receiver, msgId , "endOfAnswerSysMsg", inMsg.msgNum());
	support.out( outMsg ); //support is needed to send the answer
	return inMsg; 
}

//Operation without answer (serve sense)
public  IMessage inOnly( String receiver, String msgId,  String queryS ) throws Exception {
	//ILindaLike support =  
			PlatformExpert.findInSupport(receiver, msgId , false, view); //to start the support, if any
 	IMessage inMsg     =  space.in( queryS );
	return inMsg;
}

public  IMessage inOnly( String receiver, String msgId,  IMessage queryS ) throws Exception {
	//ILindaLike support =  
			PlatformExpert.findInSupport(receiver, msgId , false, view); //to start the support, if any
 	IMessage inMsg     =  space.in( ""+queryS );
	return inMsg;
}

public  IMessage rd( String receiver, String msgId, Hashtable<String,Integer> lastMsgRdMemo, String queryS ) throws Exception {
	//A look in local space, in any case
	IMessage inMsg = space.rd( lastMsgRdMemo.get(msgId+receiver), queryS ) ;
	//System.out.println("		**** CommLogic rd msgNum=" + inMsg.msgNum() + "/getMsgNum=" + inMsg.getMsgSeqNum());
	lastMsgRdMemo.put(msgId+receiver, inMsg.getMsgSeqNum() );
	return inMsg;
}
//IMessage rd version
public  IMessage rd( String receiver, String msgId, Hashtable<String,Integer> lastMsgRdMemo, IMessage queryS ) throws Exception {
	return rd(receiver,msgId,lastMsgRdMemo,""+queryS);
}
public  IMessage rdMostRecent( String receiver, String msgId, Hashtable<String,Integer> lastMsgRdMemo, String queryS ) throws Exception {
	//A look in local space, in any case
	IMessage inMsg = space.rdMostRecent( lastMsgRdMemo.get(msgId+receiver), queryS ) ;
	//System.out.println("		**** CommLogic rdwMostRecent msgNum=" + inMsg.msgNum() + "/getMsgNum=" + inMsg.getMsgSeqNum());
	lastMsgRdMemo.put(msgId+receiver, inMsg.getMsgSeqNum() );
	return inMsg;
}
//IMessage rdMostRecent version
public  IMessage rdMostRecent( String receiver, String msgId, Hashtable<String,Integer> lastMsgRdMemo, IMessage queryS ) throws Exception {
	return rdMostRecent(receiver,msgId,lastMsgRdMemo,""+queryS);
}
public  IMessage rdw( String receiver, String msgId, Hashtable<String,Integer> lastMsgRdMemo,String queryS ) throws Exception {
	//A look in local space, in any case
	IMessage inMsg = space.rdw( lastMsgRdMemo.get(msgId+receiver), queryS ) ;
	//System.out.println("		**** CommLogic rdwMostRecent msgNum=" + inMsg.msgNum() + "/getMsgNum=" + inMsg.getMsgSeqNum());
	lastMsgRdMemo.put(msgId+receiver, inMsg.getMsgSeqNum() );
	return inMsg;
}

//IMessage rdw version
public  IMessage rdw( String receiver, String msgId, Hashtable<String,Integer> lastMsgRdMemo,IMessage queryS ) throws Exception {
 	return rdw(receiver,msgId,lastMsgRdMemo,""+queryS);
}

public  IMessage rdwMostRecent( String receiver, String msgId, Hashtable<String,Integer> lastMsgRdMemo,String queryS ) throws Exception {
	//A look in local space, in any case
	IMessage inMsg = space.rdwMostRecent( lastMsgRdMemo.get(msgId+receiver), queryS ) ;
	//System.out.println("		**** CommLogic rdwMostRecent msgNum=" + inMsg.msgNum() + "/getMsgNum=" + inMsg.getMsgSeqNum());
	lastMsgRdMemo.put(msgId+receiver, inMsg.getMsgSeqNum() );
	return inMsg;
}
//IMessage rdwMostRecent version
public  IMessage rdwMostRecent( String receiver, String msgId, Hashtable<String,Integer> lastMsgRdMemo,IMessage queryS ) throws Exception {
 	return rdwMostRecent(receiver,msgId,lastMsgRdMemo,""+queryS);
}
/*
*  MANY OUT
*/
public IAcquireManyReply outMany(
		String senderName, String msgId, Vector<String> recNames, 
		Vector<String> msgOut, Vector<String> queries) throws Exception{
	Vector<ILindaLike> supports = prepareSupports(senderName,msgId,recNames);
	return doOutMany( senderName,supports.iterator(),  msgOut.iterator(), queries.iterator() );
}

protected Vector<ILindaLike> prepareSupports( 
			String senderName, String msgId, Vector<String> recNames ) throws Exception{
	Vector<ILindaLike> supports = new Vector<ILindaLike>();
	Iterator<String> itr 	= recNames.iterator();
	while( itr.hasNext() ){
		supports.add( findOutSupport(senderName,msgId,itr.next()) );
 	}	
	return supports;
}

protected ILindaLike findOutSupport(
	String senderName, String msgId, String receiverName ) throws Exception{
	return PlatformExpert.findOutSupport(receiverName, msgId ,senderName ,view);
}

protected IAcquireManyReply doOutMany( String subjName,Iterator<ILindaLike> itsup, 
        Iterator<String> itmsgOut, Iterator<String> itquery) throws Exception{
Vector<IMessage> querySet 	= new Vector<IMessage>();
	while( itsup.hasNext() ){
		ILindaLike supp = itsup.next();
		String msg 		= itmsgOut.next();
		String query 	= itquery.next();
		querySet.add( new Message(query) );
		new ExecOut(supp,msg ).start();	
	}
	AcquireManyReply replyHandle = new AcquireManyReply(subjName,querySet,view);
	return replyHandle;
}
private class ExecOut extends Thread{
	private ILindaLike supp ;
	private String msg;
	public ExecOut(ILindaLike supp,String msg){
		this.supp = supp;
		this.msg = msg;
	}
	public void run(){
		try {
			supp.out( msg );
		} catch (Exception e) {
			//Generate an exception message TODO
//			LindaLike.getSpace().out( " " );
			System.out.println( "		**** ExecOut ERROR " + e);
		}
	}
}

/*
*  MANY IN
*/
public Vector<IMessage> prepareInput(boolean mostRecent,String subjName, ISysKb kb, String[] msgList,  
		 IPolicy policy ) throws Exception {
	Vector<IMessage> inpList = new Vector<IMessage>();
	int n = msgList.length;
 	for( int i=0; i<n;i++ ){
		String msgId = msgList[i];
		//System.out.println("		prepareInput " + msgId);
		IMessage m;
		if( kb.isSignal(msgId))
			m= new Message( MsgUtil.bm( msgId, "SOURCE", msgId, "ANY", "N")) ;
		else{
			PlatformExpert.findInSupport(subjName,msgId,RunTimeKb.getInputConnMsg(msgId),view );
			 m = new Message(
				 MsgUtil.bm(MsgUtil.channelInWithPolicy(policy,subjName, msgId), 
				 	"SOURCE", msgId, "ANY", "N")) ;
				 	
  		}
  		inpList.add( m );
	}
	return inpList;
}

public Vector<IMessage> prepareInput(boolean mostRecent, String subjName, ISysKb kb, Object[] msgList,  
		 IPolicy policy ) throws Exception {
	Vector<IMessage> inpList = new Vector<IMessage>();
	int n = msgList.length;
 	for( int i=0; i<n;i++ ){
		String msgId = (String)msgList[i];
		//System.out.println("		prepareInput " + msgId);
		IMessage m;
		if( kb.isSignal(msgId))
			m= new Message( MsgUtil.bm( msgId, "SOURCE", msgId, "ANY", "N")) ;
		else{
			PlatformExpert.findInSupport(subjName,msgId,RunTimeKb.getInputConnMsg(msgId),view );
			 m = new Message(
				 MsgUtil.bm(MsgUtil.channelInWithPolicy(policy,subjName, msgId), 
				 	"SOURCE", msgId, "ANY", "N")) ;
				 	
  		}
  		inpList.add( m );
	}
	return inpList;
}


//Select a message
public IMessage selectOneMessage( boolean mostRecent, String subjName,ISysKb kb, Hashtable<String,Integer> lastMsgRdMemo,
        Vector<IMessage> queries ) throws Exception {
IMessage mr;
   	if( mostRecent )
   		mr = space.selectMostRecent(subjName,lastMsgRdMemo, queries);
	else        	
 		mr = space.select(subjName,lastMsgRdMemo, queries);
   //if( kb.isSignal( mr.msgId() )){
   int lastMsgNum = mr.getMsgSeqNum();
   lastMsgRdMemo.put(mr.msgId()+subjName, lastMsgNum); //SET THE LOCAL TIME
   System.out.println("			*** CommLoigc " + subjName + " selectOneMessage "  +  mr + " lastMsgNum=" + lastMsgNum);
 //}
 return mr;
}
 
/*
* Called by the application main to terminates all the SenseRemote threads
*/
public static void terminate() throws Exception{
}

}
