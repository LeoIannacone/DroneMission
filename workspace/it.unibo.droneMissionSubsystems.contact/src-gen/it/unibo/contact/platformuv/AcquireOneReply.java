/*
*  Generated by AN Unibo
*/
package it.unibo.contact.platformuv;
import it.unibo.is.interfaces.IMessage;
import it.unibo.is.interfaces.IOutputView;
import it.unibo.is.interfaces.platforms.IAcquireOneReply;
import it.unibo.is.interfaces.platforms.ILindaLike;
import it.unibo.is.interfaces.platforms.IMessageAndContext;
import it.unibo.is.interfaces.platforms.IRawBuffer;
import java.util.Vector;

public class AcquireOneReply extends Thread implements IAcquireOneReply{
 protected String msgIn;
 protected ILindaLike core; 
 private IMessage replyMsg = null;
 private boolean debug = false;
 protected IOutputView view;
 protected boolean timeOutexpired = false;
 private Vector<IMessage> answers;
 private boolean goon = true;
 private boolean consumed = false;
 protected String myself;
 protected String receiver;
 protected String msgId;
 
	public AcquireOneReply( String myself, String receiver, String msgId, ILindaLike core, String msgIn, IOutputView view ){	
		this.myself   = myself;
		this.receiver = receiver;
		this.msgId    = msgId;
 		this.core  = core;
		this.msgIn = msgIn;		 
		this.view  = view;
		answers = new Vector<IMessage>();
		if( System.getProperty("medclTrace") != null ) 
			debug = System.getProperty("medclTrace").equals("set") ;
 		//System.out.println("***  AcquireOneReply: myself= " + myself + " receiver="  + receiver   + " msgId=" +  msgId + " " + this);		
		start();
	}

	public void run() {
  		while( goon ) {
			consumed = false;
			handleAnswer(); 
 		}
 		//System.out.println("		*** AcquireOneReply " + msgIn + " ENDS");
	}
 
	protected synchronized void handleAnswer() {
		try {
			println("checking for msgIn=" + msgIn  ); 
 			replyMsg = core.in( msgIn );
			println("found " + replyMsg );
			IMessage copyOfreplyMsg = replyMsg;
			if( replyMsg.msgContent().contains(IMessageAndContext.endMessage) ){
				notifyAll();
				goon = false;
				return;
			}
			notifyAll();
			while( ! consumed ) wait();			
	 	 	goon = ! ( copyOfreplyMsg.msgContent().contains(IMessageAndContext.endMessage)
	 	 			   ||  copyOfreplyMsg.msgContent().contains("exception") );
 		} catch (Exception e) {
			e.printStackTrace();
		}
	}
 
	public synchronized IMessage getReplyWaiting() throws Exception {
		//println(" ++++ getReplyWaiting " );
		IMessage myreplyMsg = null;
		while( replyMsg == null ){
				//println(" ++++ waits " );
	 			wait();
	 	}
	 	answers.add(replyMsg);
 	 	myreplyMsg = replyMsg;
 	 	replyMsg = null;	//to block the next acquireReply
		consumed = true;	//to unblock the in
		notifyAll();
		return myreplyMsg;
	}

	public boolean replyAvailable(){
		return replyMsg != null;
	}
	public IMessage acquireReply() throws Exception{
 		IMessage m = getReplyWaiting();
  		return m;
	}
	
	
	
	public IMessage acquireReply(int timeOut) throws Exception{
		//Wait until timeout or reply
		new Timer(1, msgIn, answers , timeOut);		
 		IMessage m = getReplyWaiting();
 		return m;
	}
  
	public IRawBuffer acquireRawReply() throws Exception{ 
		//System.out.println("***  AcquireOneReply: myself= " + myself + " receiver="  + receiver   + " msgId=" +  msgId + " " + this);		
		 throw new Exception("Raw messages are not allowed in shared memory");
	}
 
	protected void println( String msg ){
 		String m = "	*%* AcquireOneReply "+ msgIn + " " + msg;
 		if( debug ) 
			 if( view != null )
				 view.addOutput( m );
			 else System.out.println(m);		
	}			
}
